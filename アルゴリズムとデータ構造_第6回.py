# -*- coding: utf-8 -*-
"""アルゴリズムとデータ構造_第6回.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14pwoiBOO-mdu8V2Y4PE7jJcRGZMT3Ych

# 様々なソートアルゴリズム

今回は

*   マージソート
*   クイックソート

について取り扱う．

ソートを行う対象となるリストを用意する．まずはじめに乱数を用いてリストを用意する方法を復習しよう（不安な人は第03回の授業資料やGoogle Colabを見直すこと）．
"""

import random
test1_list = [random.randint(0, 10000) for _ in range(8)] # random.randint(a, b)はa<=N<=bであるようなランダムな整数Nを返す．for _ in range(8)で8回繰り返す（結果として，test1_listに要素数8のリストができる）．
print(test1_list)

"""## マージソート

第05回でも触れたマージソートについて復習する．

### （下準備）ソート済み配列のマージ
まず，ソート済み配列のマージについて見ていこう（第05回でもやった）．
"""

def merge_sorted_list(sorted_array_a, sorted_array_b=[]): #sorted_array_a, sorted_array_b は何らかの方法でソートされた配列．後々のため，sorted_array_bの初期値として，空のリストとしておく．
  buff = [] # 作業用配列．初期値として空のリストにしておく．
  i, j = 0, 0
  while i < len(sorted_array_a) and j < len(sorted_array_b):
    if sorted_array_a[i] < sorted_array_b[j]:
      buff.append(sorted_array_a[i]) # .appendはリストのメソッドである．第02回で学んだので，忘れた人は復習してみてください．buffというリスト末尾にsorted_array_a[i]の値を追加する．
      i += 1
      #print("buff=",buff)
    else:
      buff.append(sorted_array_b[j])
      j += 1
      #print("buff=",buff)
  return buff + sorted_array_a[i:] + sorted_array_b[j:] # リストにリストを結合する方法として，+が用いられることもある．第02回で学んだので，忘れた人は復習してみてください．

sorted_list1 = list(range(0,16,2))
print("sorted_list1:", sorted_list1)

sorted_list2 = list(range(1,28,3))
print("sorted_list2:", sorted_list2)

sorted_list = merge_sorted_list(sorted_list1, sorted_list2)
print("--------")
print("merged list:", sorted_list)

"""### ソート済み配列のマージを用いたマージソート

「ソート済み配列のマージ」を用いて，マージソートを行う．再帰を使った方法を下記に示す（第05回でもやった）．
"""

def merge_sort_recursion(array):
  if len(array) <= 1:
    return array

  mid_idx = len(array) // 2 #arrayの中心の引数を計算している．
  left = array[:mid_idx] # arrayのはじめから中心まで
  right = array[mid_idx:] # arrayの中心からおわりまで
  #print("mid_idx=",mid_idx)
  #print("left=",left)
  #print("right=",right)
  return merge_sorted_list(merge_sort_recursion(left), merge_sort_recursion(right)) # 再帰を用いて定義（再帰については第04回で学んだので，わからない人は復習してください）

random.shuffle(test1_list) #リスト要素をシャッフルする．randomのメソッドshuffleである．モジュールrandomに関する公式ドキュメント https://docs.python.org/ja/3/library/random.html　に掲載されている．（第03回にも出てきた）
print("test1_list:", test1_list)
print("--------")

sorted_list = merge_sort_recursion(test1_list)
print("--------")
print("Result (merge sort):", sorted_list)

"""### 再帰を使わないでマージソートを行う

第05回では取り上げなかった方法として，再帰を使わない方法について以下で見てみよう．

（補足）アンパック：リストの内容を別個に取り出す．
"""

random.shuffle(test1_list) #リスト要素をシャッフルする．randomのメソッドshuffleである．モジュールrandomに関する公式ドキュメント https://docs.python.org/ja/3/library/random.html　に掲載されている．（第03回にも出てきた）
print(test1_list)
print(*test1_list) # * はアンパックを表し，リストの内容を別個に取り出す．
print(*test1_list[0:len(test1_list)//2]) # * はアンパックを表し，リストの内容を別個に取り出す．

"""（補足） `for 変数名 in イテラブルオブジェクト`"""

random.shuffle(test1_list) #リスト要素をシャッフルする．randomのメソッドshuffleである．モジュールrandomに関する公式ドキュメント https://docs.python.org/ja/3/library/random.html　に掲載されている．（第03回にも出てきた）
print("test1_list",test1_list)
for v in test1_list:
  print(v)

"""再帰を使わないでマージソートを行う．"""

def step(array):
  buff = []
  for i in range(0, len(array), 2):
    buff.append(merge_sorted_list(*array[i:i+2])) #.appendはリストのメソッドである（上記参照）．リスト末尾に要素を追加する．忘れた人は第02回や https://docs.python.org/ja/3/tutorial/datastructures.html で復習．* はアンパックを表し，リストの内容を別個に取り出して，関数に渡している．
    print("*array[i:i+2]=",*array[i:i+2])
    print("merge_sorted_list(*array[i:i+2])=",merge_sorted_list(*array[i:i+2]))
  return buff

def merge_sort(array):
  buff = [[v] for v in array] # array の各要素をリストとし，そのリストを要素とするリストを作成．上記の for 変数名 in イテラブルオブジェクト: の部分の説明を参照．
  print("buff(before step):", buff)
  while len(buff[0]) != len(array):
    buff = step(buff)
    print("buff(after step):", buff)
    print("============")

  return buff[0]

random.shuffle(test1_list) #リスト要素をシャッフルする．randomのメソッドshuffleである．モジュールrandomに関する公式ドキュメント https://docs.python.org/ja/3/library/random.html　に掲載されている．（第03回にも出てきた）
print("test1_list:", test1_list)
print("--------")

sorted_list = merge_sort(test1_list)
print("--------")
print("Result (merge sort):", sorted_list)

"""## クイックソート"""

def quick_sort(array):

  if array == []: # arrayが空リストである場合
    return array
  
  pivot = array[0] # pivotとしてarrayの先頭要素を選択
  left_array = [] # 初期値として空リストを代入
  right_array = [] # 初期値として空リストを代入
  pivot_array = [] # 初期値として空リストを代入

  for v in array: # array の要素(v)を一つずつ調べる．
    if v < pivot:
      left_array.append(v) # v < pivot ならば，left_array の要素末尾に v を追加 ．append はリストのメソッド（さっきも出てきた）
    elif v == pivot:
      pivot_array.append(v) # v == pivot ならば，pivot_array の要素末尾に v を追加 ．append はリストのメソッド（さっきも出てきた）
    else:
      right_array.append(v) # v > pivot ならば，right_array の要素末尾に v を追加 ．append はリストのメソッド（さっきも出てきた）
  
  #print(left_array, pivot_array, right_array)
  return quick_sort(left_array) + pivot_array + quick_sort(right_array) # リスト + リストでリストの結合が行われる．忘れた人は第02回を復習．

random.shuffle(test1_list) #リスト要素をシャッフルする．randomのメソッドshuffleである．モジュールrandomに関する公式ドキュメント https://docs.python.org/ja/3/library/random.html　に掲載されている．（第03回にも出てきた）
print("test1_list:", test1_list)
print("--------")

sorted_list = quick_sort(test1_list)
print("--------")
print("Result (quick sort):", sorted_list)

"""### pivotの選び方の重要性"""

import time # 時間測定のため，timeモジュールをimport

almost_sorted_list1 = list(range(0,10000,2)) #[0, 2, ..., 9998]なるリストを生成
#print(almost_sorted_list1)
for _ in range(5):
  """
  以下で5回だけ（5ペアだけ）要素を交換する．
  """
  i = random.randint(1, len(almost_sorted_list1) - 1)
  j = i
  while j == i:
    j = random.randint(1, len(almost_sorted_list1) - 1)
  
  almost_sorted_list1[i], almost_sorted_list1[j] = almost_sorted_list1[j], almost_sorted_list1[i]
  
#print(almost_sorted_list1)

time_start = time.time()
for _ in range(20): # 20回merge_sort_recursionを呼び出す．
  merge_sort_recursion(almost_sorted_list1)

time_end = time.time()
time_elapsed = time_end - time_start
print(time_elapsed)

### Google Colabだとおそらくエラーが出る（再帰の最大回数制限）ので，以下の2つのコードブロックを実行してからここに戻ってくる．
time_start = time.time()
for _ in range(20): # 20回quick_sortを呼び出す．
  quick_sort(almost_sorted_list1)

time_end = time.time()
time_elapsed = time_end - time_start
print(time_elapsed)

"""再帰回数上限が定められている．（第04回「（補足）Pythonでの再帰呼び出し数の上限の調べ方」を参照．以下にも同じ内容を貼り付ける．）"""

import sys # sys については https://docs.python.org/ja/3/library/sys.html を参照のこと（第02回でも sys については紹介）．
sys.getrecursionlimit() # 上記URLに説明が載っている．

sys.setrecursionlimit(10000)
sys.getrecursionlimit() # 上記URLに説明が載っている．

"""#### 工夫1
任意の3個の要素を取り出し，その中央値を持つ要素をpivotとして採用するという方針をとってみる．
"""

def median_3(a, b, c):
  if a >= b:
    if b >= c:
      return b
    elif a <= c:
      return a
    else:
      return c
  elif a > c:
    return a
  elif b > c:
    return c
  else:
    return b

median_3(222, 128, 192)

def quick_sort_modified1(array):

  if len(array) <= 1: # arrayが空あるいは要素が1つだけの場合の例外処理．
    return array
  
  if len(array) == 2: # arrayの要素が2個の場合の例外処理．
    if array[1] < array[0]:
      array[0], array[1] = array[1] ,array[0]
      return array
    else:
      return array

  # quick_sort(array) との違いは，ここから
  i = random.randint(0, len(array) - 1)
  j = i
  while j == i:
    j = random.randint(0, len(array) - 1)

  k = j
  while (k-j) * (k-i) == 0: # k == i or k == jと書いても良い．
    k = random.randint(0, len(array) - 1)

  pivot = median_3(array[i], array[j], array[k])
  # quick_sort(array) との違いは，ここまでである．

  left_array = []
  right_array = []
  pivot_array = []

  for v in array:
    if v < pivot:
      left_array.append(v)
    elif v == pivot:
      pivot_array.append(v)
    else:
      right_array.append(v)
  
  return quick_sort_modified1(left_array) + pivot_array + quick_sort_modified1(right_array)

test_list_a = []
sorted_list = quick_sort_modified1(test_list_a)
print(sorted_list)

test_list_b = [1]
sorted_list = quick_sort_modified1(test_list_b)
print(sorted_list)

test_list_c = [3, 1]
sorted_list = quick_sort_modified1(test_list_c)
print(sorted_list)

test_list_d = [4, 5]
sorted_list = quick_sort_modified1(test_list_d)
print(sorted_list)

test_list_e = [8, 10, 5]
sorted_list = quick_sort_modified1(test_list_e)
print(sorted_list)

time_start = time.time()
for _ in range(20): # 20回quick_sort_modified1を呼び出す．
  quick_sort_modified1(almost_sorted_list1)

time_end = time.time()
time_elapsed = time_end - time_start
print(time_elapsed)

"""#### 工夫2
ピボットをランダムに選択するという方針をとってみる．
"""

def quick_sort_modified2(array):

  if array == []: #空リストの場合の例外処理
    return array

  pivot = random.choice(array) # quick_sort(array) との違いはここだけ．random.choice(array)はarrayからランダムに要素を抽出．https://docs.python.org/ja/3/library/random.html　を参照．
  left_array = []
  right_array = []
  pivot_array = []

  for v in array:
    if v < pivot:
      left_array.append(v)
    elif v == pivot:
      pivot_array.append(v)
    else:
      right_array.append(v)
  
  return quick_sort_modified2(left_array) + pivot_array + quick_sort_modified2(right_array)

test_list_a = []
sorted_list = quick_sort_modified2(test_list_a)
print(sorted_list)

test_list_b = [1]
sorted_list = quick_sort_modified2(test_list_b)
print(sorted_list)

test_list_c = [3, 1]
sorted_list = quick_sort_modified2(test_list_c)
print(sorted_list)

test_list_d = [4, 5]
sorted_list = quick_sort_modified2(test_list_d)
print(sorted_list)

test_list_e = [8, 10, 5]
sorted_list = quick_sort_modified2(test_list_e)
print(sorted_list)

time_start = time.time()
for _ in range(20): # 20回quick_sort_modified2を呼び出す．
  quick_sort_modified2(almost_sorted_list1)

time_end = time.time()
time_elapsed = time_end - time_start
print(time_elapsed)

"""## （注）組み込み関数のソート

第03回でも取り上げたように，Pythonを使う場合には，組み込み関数`sorted`を使うか，あるいは，リストのメソッドである`sort`を用いるのが一般的である．
"""

time_start = time.time()
sorted(almost_sorted_list1)
time_end = time.time()
time_elapsed = time_end - time_start
print(time_elapsed * 20) # 上記のアルゴリズムの計算時間測定では20回実行したので，*20として合わせた

time_start = time.time()
almost_sorted_list1.sort() # リストのsortメソッド．https://docs.python.org/ja/3/tutorial/datastructures.html　のlist.sort() を参照．sorted()と異なり，test1_list自体を書き換える．
time_end = time.time()
time_elapsed = time_end - time_start
print(time_elapsed * 20) # 上記のアルゴリズムの計算時間測定では20回実行したので，*20として合わせた