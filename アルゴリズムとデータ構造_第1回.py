# -*- coding: utf-8 -*-
"""第1回アルゴリズムとデータ構造.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1y9mdyhpCcAUfmRE21K8e0vUn5383qinh

# プログラミングにおける3つの基本処理

プログラミングにおける3つの基本処理は，**順次，分岐，反復**である．

以下については，渡辺先生の「プログラミング基礎同演習」の復習となるので，適宜，渡辺先生の講義ノート

https://kaityo256.github.io/python_zero/

を参照するとよい．または，Python公式サイトのチュートリアル

https://docs.python.org/ja/3/tutorial/index.html

は大変勉強になるので，「Pythonでのプログラミングが不安だけどどうしたら良いだろう？」というときには，これを参照しながら勉強するのもよい．

## 基本処理：順次

上から書かれた命令文を**順次**実行する．
"""

print("aを3で割った余りは0です．")
print("aを3で割った余りは1です．")
print("aを3で割った余りは2です．")

"""命令文の順番を変えると出力結果が変わる．"""

print("aを3で割った余りは1です．")
print("aを3で割った余りは0です．")
print("aを3で割った余りは2です．")

"""## 基本処理：分岐

条件によってどの命令文を実行するかを変える（**分岐**させる）ことができる．

具体例を通じて分岐について見ていこう．分岐については，渡辺先生の「プログラミング基礎同演習」の講義で取り扱っている．講義ノート

*   https://kaityo256.github.io/python_zero/basic/index.html
*   https://speakerdeck.com/kaityo256/python-basic

を参考にするとよい．あるいは，Python公式サイトのチュートリアルの

https://docs.python.org/ja/3/tutorial/controlflow.html#if-statements

を参考にすると良い．

### `if`文単独で使用の場合

```
if 条件:
  処理
```
と書くと，(条件)が正しいとき，(処理)が行われる．ただしここで，(処理)の部分については，インデント（字下げ）を行うことに注意．下記のようにインデントを行わなかった場合，エラーが返ってくる．
```
if 条件:
処理
```

参考：渡辺先生の「プログラミング基礎同演習」の講義ノート

https://kaityo256.github.io/python_zero/hello/index.html

のオフサイドルールの部分を参照．
"""

a = 4
if a%3 == 0:
  print("aを3で割った余りは0です．")

"""### `if`文と`else`文使用の場合

```
if 条件:
  処理1
else:
  処理2
```

と書くと，

*   (条件)が正しいとき，(処理1)が行われる．
*   (条件)が正しくないとき(処理2)が行われる．

となる．ただしここで，`if`文と`else`文のインデントは同一位置となる．
"""

a = 4
if a%3 == 0:
  print("aを3で割った余りは0です．")
else:
  print("aを3で割った余りは0ではありません．")

"""### `if`文と`elif`文と`else`文使用の場合

```
if 条件A:
  処理1
elif 条件B:
  処理2
else:
  処理3
```

と書くと，

*   (条件A)が正しいとき，(処理1)が行われる．
*   (条件A)が正しくなく，かつ(条件B)が正しいとき，(処理2)が行われる．
*   (条件A)が正しくなく，かつ(条件B)が正しくないとき，(処理3)が行われる．

となる．ただしここで，`if`文と`elif`文と`else`文のインデントは同一位置となる．

"""

a = 4
if a%3 == 0:
  print("aを3で割った余りは0です．")
elif a%3 == 1:
  print("aを3で割った余りは1です．")
else:
  print("aを3で割った余りは2です．")

"""## 基本処理：反復

具体例を通じて反復について見ていこう．反復については，渡辺先生の「プログラミング基礎同演習」の講義で取り扱っている．講義ノート

*   https://kaityo256.github.io/python_zero/basic/index.html
*   https://speakerdeck.com/kaityo256/python-basic

を参考にするとよい．あるいは，Python公式サイトのチュートリアルの

https://docs.python.org/ja/3/tutorial/controlflow.html#for-statements

を参考にすると良い．

### `for`文を1つのみ用いた簡単な例

```
for i in range(4):
  処理1
```

と書くと，`i`の値を0から4まで,1ずつ増加させながら(処理1)を繰り返す．ここで，`i`を**ループカウンタ**と呼ぶ．

`range()`関数については，

https://docs.python.org/ja/3/tutorial/controlflow.html#the-range-function
https://docs.python.org/ja/3/library/stdtypes.html#range

を参照．
"""

for i in range(4):
  print("Hello world!")

"""上記では，ループカウンタが不要である（いま，繰り返し回数が何回目かを知る必要がない）．そのときには，

```
for _ in range(4):
  処理1
```

と書くと，(処理1)を4回繰り返すことになる．
"""

for _ in range(4):
  print("Hello world!")

"""### `for`文を入れ子構造にした簡単な例

```
for i in range(4):
  for j in range(5):
    処理1
```

のように書くことで，入れ子構造にすることができる．インデントの位置に注意．具体例を見ていこう．
"""

for i in range(4):
  for j in range(5):
    print ("i=", i, "j=", j, ": i*j=", i*j)

"""### `for`文の中に条件分岐を入れる簡単な例"""

for a in range(15):
  if a%3 == 0:
    print("a=", a, ": aを3で割った余りは0です．")
  elif a%3 == 1:
    print("a=", a, ": aを3で割った余りは1です．")
  else:
    print("a=", a, ": aを3で割った余りは2です．")

"""`range()`関数の部分を変えて上記のコードの振る舞いの変化を見てみよう．2から20までの偶数について，3で割った余りを上記のように判定することを実装してみる．`range()`関数は，

https://docs.python.org/ja/3/library/stdtypes.html#range

にあるように，`range(start, stop[, step])`の形で使うことができることを利用する．
"""

for a in range(2,22,2):
  if a%3 == 0:
    print("a=", a, ": aを3で割った余りは0です．")
  elif a%3 == 1:
    print("a=", a, ": aを3で割った余りは1です．")
  else:
    print("a=", a, ": aを3で割った余りは2です．")

"""## これまでの振り返り

プログラミングにおける3つの基本処理は，**順次，分岐，反復**であることを見てきた．これらを用いて簡単な数値計算を行ってみよう．

### Newton法：代数方程式の数値解法

方程式$y=f(x)=0$を数値的に解くことを考える．Newton法は以下の手続きを行う．

1.   適当な値$x_0$を取る．
2.   点$(x_0,f(x_0))$における$y=f(x)$の接線を求めると，$y = f'(x_0(x-x_0)+f(x_0)$となる．
3.   この接線が$x$軸と交わる場所を$(x_1,0)$とすると，$x_1 = x_0 - \frac{f(x_0)}{f'(x_0)}$となる．
4.   以下同様に繰り返す．すなわち，$x_{n+1}=x_n - \frac{f(x_n)}{f'(x_n)}$

この手続により，「性質の良い」方程式の場合には解は収束する．

第1ステップから第3ステップまでを表したのが下図である．

ここで「性質の良い」とやや「にごした」書き方をしたが，より正確には，

$f$が解を含むある区間$[a, b]$で，二回微分可能かつ単調で下あるいは上に凸であり，また，$f$ならびに$f'$が計算可能であるとき，$x_{n+1}=x_n - \frac{f(x_n)}{f'(x_n)}$を繰り返せば，$f(x)=0$の区間$[a, b]$上の唯一の解が得られる．

と言える．

#### $5x^2 -1 = 0$をNewton法で解く

`newton1(x)`：繰り返し数を指定して計算する方法で解く．
"""

def newton1(x):
  num_iterations = 10
  for _ in range(num_iterations):
    x = x - (5*x**2 - 1) / (10*x)
    print(x)

newton1(1.0)

newton1(-2.0)

newton1(1.0+1.0j)

newton1(0.0+0.1j)

"""`newton2(x)`：$x_n$と$x_{n+1}$がほぼ同じ値になったときに計算を止める方法で解く．"""

def newton2(x):
  dummy_large = 1e8
  dummy_small = 1e-8
  diff = dummy_large
  xold = x
  while diff > dummy_small:
    xnew = xold - (5*xold**2 - 1) / (10*xold)
    diff = abs(xnew-xold)
    xold = xnew

  return xold

newton2(1.0)

newton2(-2.0)

newton2(1.0+1.0j)

"""`newton3(x)`：$x_n$と$x_{n+1}$がほぼ同じ値になったときに計算を止める方法（ただし，最大繰り返し数を指定する）で解く．"""

def newton3(x):
  dummy_large = 1e8
  dummy_small = 1e-8
  num_iterations = 10
  diff = dummy_large
  xold = x
  iterations = 0
  while diff > dummy_small and iterations < num_iterations: # and は渡辺先生の講義ノートの「条件分岐と繰り返し処理」で説明されている．
    xnew = xold - (5*xold**2 - 1) / (10*xold)
    diff = abs(xnew-xold)
    xold = xnew
    iterations += 1

  iflag_converge = 'Y'
  if iterations == num_iterations:
    iflag_converge = 'N'

  return iflag_converge, xold

newton3(1.0)

newton3(-2.0)

newton3(1.0+1.0j)

"""#### $x^2-x+4=0$をNewton法を用いて解く"""

def newton4(x):
  num_iterations = 10
  for _ in range(num_iterations):
    x = x - (x**2 - x + 4) / (2*x - 1)
    print(x)

newton4(1.0) ### 収束しない

newton4(1.0+1.0j)

"""#### $x^3-2x^2-11x+12=0$をNewton法を用いて解く"""

def newton5(x):
  dummy_large = 1e8
  dummy_small = 1e-8
  num_iterations = 100
  diff = dummy_large
  xold = x
  iterations = 0
  while diff > dummy_small and iterations < num_iterations: # and は渡辺先生の講義ノートの「条件分岐と繰り返し処理」で説明されている．
    xnew = xold - (xold**3 - 2 * xold**2 - 11 * xold + 12) / (3 * xold**2 - 4 * xold - 11)
    diff = abs(xnew-xold)
    xold = xnew
    iterations += 1

  iflag_converge = 'Y'
  if iterations == num_iterations:
    iflag_converge = 'N'

  return iflag_converge, xold

newton5(2.0)

newton5(5.2)

newton5(-4.0)

"""#### $x^3+3x^2+2x+1=0$をNewton法を用いて解く"""

def newton6(x):
  dummy_large = 1e8
  dummy_small = 1e-8
  num_iterations = 100
  diff = dummy_large
  xold = x
  iterations = 0
  while diff > dummy_small and iterations < num_iterations:
    xnew = xold - (xold**3 + 3 * xold**2 + 2 * xold + 1) / (3 * xold**2 + 3 * xold + 2)
    diff = abs(xnew-xold)
    xold = xnew
    iterations += 1

  iflag_converge = 'Y'
  if iterations == num_iterations:
    iflag_converge = 'N'

  return iflag_converge, xold

newton6(-3.0)

newton6(-0.33764102+0.56227951j)

newton6(-0.33764102-0.56227951j)

"""### 余談：NumPyを用いた代数方程式の解法

方程式の数値的解法としてNewton法を学ぶことは科学技術計算のプログラミング能力を高める上で重要ではあるが，PythonではNumPyを用いて簡単に方程式の数値的解法を行うことができる．NumPyについて知らない，あるいは，使ってみたことあるけど忘れてしまったという人は，渡辺先生の「プログラミング同演習」の講義テキスト https://kaityo256.github.io/python_zero/ の「NumPyとSciPyの使い方」の章を参考にすると良い．

また，公式ドキュメントにあたることもとても大事である．

NumPy：https://numpy.org/

$a_n x^n + a_{n-1} x^{n-1} + \cdots + a_0 = 0$

の数値解を求めるには，`numpy.roots()` を用いれば良い．

以下，$3x^3+2x^2+4x+1=0$の数値解を求める方法である．
"""

import numpy as np
np.roots([3, 2, 4, 1])

import numpy as np
np.roots([1, -2, -11, 12])

import numpy as np
np.roots([1, 3, 2, 1])

"""### 発展的な話題

上記では，方程式の数値的解法としてNewton法を紹介するにあたり，具体例として一変数の方程式を取り上げた．二変数の場合や多変数の場合についてどのような方法があるか調べてみるとよい．また時間があればそれらについてプログラムを作成するとよい．

### 相当に発展的な話題

Newton法は基本的な方程式の数値解法の一つとしてよく知られているが、この方法の理論についてレビュー論文がある。読みこなすのは相当に苦労する難しい論文であるが、一応紹介する。

A. Galántai, "The theory of Newton's method", Journal of Computational and Applied Mathematics, Vol. 124, pages 25-44 (2000). [URL](https://www.sciencedirect.com/science/article/pii/S0377042700004350)
"""