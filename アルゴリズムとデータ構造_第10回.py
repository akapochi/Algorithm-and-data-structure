# -*- coding: utf-8 -*-
"""アルゴリズムとデータ構造_第10回.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1d-kB6xaVvk2rt6eLPWiZky9p9b2PQh6m

# グリッドグラフ上の最短経路の個数を求める
"""

def count_nearest_routes1(num_horizontal, num_vertical):
  route = [[0 for _ in range(num_vertical+1)] for _ in range(num_horizontal+1)]
  print("route=",route)

  for m in range(num_horizontal+1):
    route[m][0] = 1

  for n in range(1, num_vertical+1):
    route[0][n] = 1
    for m in range(1, num_horizontal+1):
      route[m][n] = route[m-1][n] + route[m][n-1]

  return route[num_horizontal][num_vertical]

print("Num of shortest paths:", count_nearest_routes1(4, 5))

import functools # 公式ドキュメント : https://docs.python.org/ja/3/library/functools.html　を参照。第04回最後でも少し触れた。
@functools.lru_cache(maxsize = None)
def count_nearest_routes2(num_horizontal, num_vertical):
  if (num_horizontal == 0) or (num_vertical == 0):
    return 1

  return count_nearest_routes2(num_horizontal-1, num_vertical) + count_nearest_routes2(num_horizontal, num_vertical-1) # 再帰

print("Num of shortest paths:", count_nearest_routes2(4, 5))

"""# 最短経路を探索する方法



*   Bellman-Ford法
*   Dijkstra法

## Bellman-Ford法
"""

def bellman_ford(edges, start_vertex, num_vertices):
  dist = [float('inf') for _ in range(num_vertices)] # すべての頂点に値「無限大」を設定（この値は「仮の距離」を表す）。
  dist[start_vertex] = 0 # 出発地点の距離を0とする

  changed = True
  while changed: # changed == True の間ずっと回る
    print("TRIAL")
    changed = False
    for edge in edges: #edgesのデータはリスト[地点、地点、距離]のリストとなっている。
      print(edge)
      if dist[edge[1]] > dist[edge[0]] + edge[2]:
        dist[edge[1]] = dist[edge[0]] + edge[2] #頂点に辺のコストを加算した値が、もう一方の頂点のコストより小さい場合、その値に更新する。
        changed = True #更新した場合Trueとする。一度も更新しなければ、ここを通過しないので、changed = Falseのままとなる。

  return dist


weighted_directed_graph1_for_bf = [[0, 1, 4], [0, 2, 3], [0, 3, 5], [1, 4, 6], [1, 6, 3], [2, 4, 1], [3, 5, 3], [4, 6, 5], [4, 7, 2], [5, 7, 4], [6, 7, 2], [6, 8, 4], [7, 8, 1]]
print("Distances in the shortest path:", bellman_ford(weighted_directed_graph1_for_bf, 0, 9))


weighted_directed_graph2_for_bf = [[0, 1, 4], [0, 2, 3], [0, 3, 5], [1, 4, 6], [1, 6, -3], [2, 4, 1], [3, 5, 3], [4, 6, -5], [4, 7, 2], [5, 7, 4], [6, 7, 2], [6, 8, 4], [7, 8, 1]]
print("Distances in the shortest path:", bellman_ford(weighted_directed_graph2_for_bf, 0, 9))

"""基礎問題1"""

weighted_directed_graph3_for_bf = [[0, 1, 4], [0, 2, 6], [0, 3, 5], [1, 4, 6], [1, 6, 2], [2, 4, 3], [3, 4, 2], [3, 5, 3], [4, 6, 5], [4, 7, 2], [5, 7, 4], [5, 8, 2], [6, 7, 2], [6, 9, 4], [7, 9, 7], [8, 7, 1], [8, 9, 4]]
print("Distances in the shortest path:", bellman_ford(weighted_directed_graph3_for_bf, 0, 10))

"""基礎問題2"""

weighted_directed_graph4_for_bf = [[0, 1, 4], [0, 2, 6], [0, 3, 5], [1, 4, 6], [1, 6, -2], [2, 4, 3], [3, 4, 2], [3, 5, 3], [4, 6, -5], [4, 7, 2], [5, 7, -4], [5, 8, 2], [6, 7, 2], [6, 9, 4], [7, 9, 7], [8, 7, 1], [8, 9, 4]]
print("Distances in the shortest path:", bellman_ford(weighted_directed_graph4_for_bf, 0, 10))

"""理解度確認レポート（後半）の基礎問題8"""

weighted_directed_graph5_for_bf = [[0, 1, 4], [0, 2, 2], [0, 3, 5], [1, 6, 4], [2, 4, 4], [3, 4, 3], [3, 5, 3], [4, 6, 5], [4, 7, 3], [5, 7, 4], [5, 8, 2], [6, 7, 2], [6, 9, 4], [7, 9, 7], [8, 7, 2], [8, 9, 4]]
print("Distances in the shortest path:", bellman_ford(weighted_directed_graph5_for_bf, 0, 10))

"""## Dijkstra's algorithm"""

def dijkstra(edges, start_vertex, num_vertices):
  dist = [float('inf')] * num_vertices # すべての頂点に値「無限大」を設定（この値は「仮の距離」を表す）。
  dist[start_vertex] = 0 # 出発地点の距離を0とする
  q = [i for i in range(num_vertices)]
  print("dist=",dist)
  print("q=",q)
  print("--------")

  while len(q) > 0: # q が空のリストになるまで繰り返す。
    r = q[0]
    for i in q:
      if dist[i] < dist[r]:
        r = i # 最もdistの値が小さい頂点をrとする。

    u = q.pop(q.index(r)) #popやindexはリストのメソッド。https://docs.python.org/ja/3/tutorial/datastructures.html　や第02回を参照。
    print("u, edges[u]:", u, edges[u])
    for i in edges[u]:
      if i[0] in q:
        print("i:", i)
        if dist[i[0]] > dist[u] + i[1]:
          dist[i[0]] = dist[u] + i[1]

  return dist


weighted_directed_graph1_for_d = [[[1, 4], [2, 3], [3, 5]], [[4, 6], [6, 3]], [[4, 1]], [[5, 3]], [[6, 5], [7, 2]], [[7, 4]], [[7, 2], [8, 4]], [[8, 1]], []]
print("Distances in the shortest path:", dijkstra(weighted_directed_graph1_for_d, 0, 9))

"""Dijkstra's algorithmがうまく行かない例 : """

weighted_directed_graph2_for_d = [[[1, 4], [2, 3], [3, 5]], [[4, 6], [6, -3]], [[4, 1]], [[5, 3]], [[6, -5], [7, 2]], [[7, 4]], [[7, 2], [8, 4]], [[8, 1]], []]
print("Distances in the shortest path:", dijkstra(weighted_directed_graph2_for_d, 0, 9))

"""`heapq`ライブラリ（ヒープ）を使った高速化"""

import heapq # 公式ドキュメント https://docs.python.org/ja/3/library/heapq.html を参照。第08回の最後に少しだけ触れた。


def dijkstra_by_heap(edges, start_vertex, num_vertices):
  dist = [float('inf')] * num_vertices
  flag = [True] * num_vertices
  dist[start_vertex] = 0
  q = []

  heapq.heappush(q, [0, 0])

  while len(q) > 0:
    print("q=",q)
    _, u = heapq.heappop(q)

    if flag[u]:
      flag[u] = False
      print("u=",u)
      for i in edges[u]:
        if flag[i[0]]:
          if dist[i[0]] > dist[u] + i[1]:
            dist[i[0]] = dist[u] + i[1]
            heapq.heappush(q, [dist[u] + i[1], i[0]])

  return dist


weighted_directed_graph1_for_d = [[[1, 4], [2, 3], [3, 5]], [[4, 6], [6, 3]], [[4, 1]], [[5, 3]], [[6, 5], [7, 2]], [[7, 4]], [[7, 2], [8, 4]], [[8, 1]], []]
print("Distances in the shortest path:", dijkstra_by_heap(weighted_directed_graph1_for_d, 0, 9))

"""Dijkstra's algorithmがうまく行かない例 : """

weighted_directed_graph2_for_d = [[[1, 4], [2, 3], [3, 5]], [[4, 6], [6, -3]], [[4, 1]], [[5, 3]], [[6, -5], [7, 2]], [[7, 4]], [[7, 2], [8, 4]], [[8, 1]], []]
print("Distances in the shortest path:", dijkstra_by_heap(weighted_directed_graph2_for_d, 0, 9))

def dijkstra_route_by_heap(edges, start_vertex, goal_vertex, num_vertices):
  dist = [float('inf')] * num_vertices
  flag = [True] * num_vertices
  dist[start_vertex] = 0
  q = []

  heapq.heappush(q, [0, [0]])

  while len(q) > 0:
    print("q=", q)
    _, u = heapq.heappop(q)
    print("u=",u)

    final = u[-1]
    if final == goal_vertex:
      return u

    for i in edges[final]:
      if dist[i[0]] > dist[final] + i[1]:
        dist[i[0]] = dist[final] + i[1]
        heapq.heappush(q, [dist[final] + i[1], u+[i[0]]])


weighted_directed_graph1_for_d = [[[1, 4], [2, 3], [3, 5]], [[4, 6], [6, 3]], [[4, 1]], [[5, 3]], [[6, 5], [7, 2]], [[7, 4]], [[7, 2], [8, 4]], [[8, 1]], []]
print("The shortest path:", dijkstra_route_by_heap(weighted_directed_graph1_for_d, 0, 8, 9))

"""## Pythonのライブラリを用いた最短経路探索の各種手法

https://docs.scipy.org/doc/scipy/reference/sparse.csgraph.html　の`shortest_path`や`dijkstra`などを参考にするとよい。また、https://networkx.org/documentation/stable/reference/algorithms/shortest_paths.html に記載されている方法も参考にすると良い。
"""