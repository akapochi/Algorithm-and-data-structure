# -*- coding: utf-8 -*-
"""アルゴリズムとデータ構造_第5回.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iKWZHJe-ReHzvJziV-iVCCO9uzNBBvMp

# 様々なソートアルゴリズム

**要求：各要素に数値が入っている長さｎの配列について，各要素の数値が小さい順に並べ替えた配列を作成せよ．**

上記の要求に対して，今回は以下の様々なソートアルゴリズムについて見ていく．

*   選択ソート
*   バブルソート
*   挿入ソート
*   シェルソート
*   ソート済みリストのマージ
*   マージソート

ソートを行う対象となるリストを用意する．まずはじめに乱数を用いてリストを用意する方法を復習しよう（不安な人は第03回の授業資料やGoogle Colabを見直すこと）．
"""

import random


test1_list = [random.randint(0, 10000) for _ in range(10)] # 先ほども出てきたが，random.randint(a, b)はa<=N<=bであるようなランダムな整数Nを返す．for _ in range(10)で10回繰り返す（結果として，test1_listに要素数10のリストができる）．
print(test1_list)

"""## 選択ソート

第03回で学んだ選択ソートについて復習する．

### **解法1：選択ソート(selection sort)**

1.   `i`に0を代入する．
2.   `i`が配列の最後の添字なら終了する．
3.   `i`番目以降の要素の中から`i`番目よりも小さい最小の値を見つけ，その添字を`j`とする．
4.   3.で値が見つかったら`i`番目と`j`番目の要素を交換する．
5.   `i`を1増やし，2.へ戻る．

コードは「（共有用）第03回アルゴリズムとデータ構造.ipynb」に掲載されているので，そちらを参照すること．

## バブルソート

### **解法2：バブルソート(bubble sort)**

1.   `i`に0を代入する．
2.   `j`に`len(array)-1`を代入する．
3.   `j`番目の要素と`j-1`番目の要素を比較し，`array[j] < array[j - 1]`ならば要素を交換する．
4.   `j != i　- 1`のときには`j`を1減らし，3.へ戻る．ただし，`j = i　- 1`のときには`i`を1増やし，2.へ戻る．
5.   `i = len(array) - 1`となったら終了

以上を実現するコードは下記のようになる．
"""

def bubble_sort(array):
  for i in range(len(array)): # 「（共有用）第02回アルゴリズムとデータ構造.ipynb」にも出てきたが，len(x)でリストxのサイズを取得できる．
    for j in range(len(array)-1, i, -1): # j = len(array)-1 から j = i+1 まで j の値を一つずつ小さくしていく．
      if array[j] < array[j-1]:
        array[j], array[j-1] = array[j-1], array[j] # array[j], array[j-1]を入れ替える
        #print("途中過程(for j)",array)
    #print("途中過程(for i)",array)
  return array

random.shuffle(test1_list) #上記でtest1_listがソートされてしまったのでリスト要素をシャッフルする．randomのメソッドshuffleである．モジュールrandomに関する公式ドキュメント https://docs.python.org/ja/3/library/random.html　に掲載されている．（第03回にも出てきた）
print("original list=",test1_list)

sorted_test1_list = bubble_sort(test1_list)
print("bubble_sort(test1_list)=",sorted_test1_list)

"""バブルソートをもう少し改良してみる．上記コードのある`i`において要素の交換回数が0回であるならば，全ての要素はソート済みである．したがって，それ以降ソートを試行する必要はない（打ち切りをすれば良い）．"""

def bubble_sort_modified1(array):
  for i in range(len(array)):
    exchange_count = 0 # i における要素の交換回数を数えるための変数exchange_countを定義し，0に初期化する．
    for j in range(len(array)-1, i, -1):
      if array[j] < array[j-1]:
        array[j], array[j-1] = array[j-1], array[j]
        exchange_count += 1 # array[j]とarray[j-1]を交換したならば，exchange_countを1増やす．
        
    if exchange_count == 0:
      break # for i in range(len(array))を抜け出す．
  return array

random.shuffle(test1_list) #上記でtest1_listがソートされてしまったのでリスト要素をシャッフルする．randomのメソッドshuffleである．モジュールrandomに関する公式ドキュメント https://docs.python.org/ja/3/library/random.html　に掲載されている．（第03回にも出てきた）
print("original list=",test1_list)

sorted_test1_list = bubble_sort_modified1(test1_list)
print("bubble_sort_modified1(test1_list)=",sorted_test1_list)

"""別の方針でバブルソートを改良してみる．ある`j`以降に交換が行われないならば，それより先頭側はソート済みである．そのことを利用して，ソートを試行する対象を絞り込む．

"""

def bubble_sort_modified2(array):
  k = 0
  while k < len(array)-1: # k < len(array) - 1である間ずっと以下が実行される．
    final = len(array)-1 # 交換が行われない位置を指定する変数 final を定義．この変数を len(array)-1に初期化
    for j in range(len(array)-1, k, -1): # 第二引数がkになっている点に注意．
      if array[j] < array[j-1]:
        array[j], array[j-1] = array[j-1], array[j]
        #print("途中過程(for j)",array)
        final = j # array[j]とarray[j-1]を交換したならば，final に j を代入する．
        
    k = final # for j in range(len(array)-1, k, -1)が終わった後の final の値を k に代入
    #print("k=",k)
    #print("途中過程(for k)",array)
  return array

random.shuffle(test1_list) #上記でtest1_listがソートされてしまったのでリスト要素をシャッフルする．randomのメソッドshuffleである．モジュールrandomに関する公式ドキュメント https://docs.python.org/ja/3/library/random.html　に掲載されている．（第03回にも出てきた）
print("original list=",test1_list)

sorted_test1_list = bubble_sort_modified2(test1_list)
print("bubble_sort_modified2(test1_list)=",sorted_test1_list)

"""バブルソートを「双方向」から行うシェーカーソート(shaker sort)（双方向バブルソート）について見ていこう．

### **解法3：シェーカーソート(shaker sort)**

1.   `left`に0を，`right`および`final`に`len(array)-1`を代入する．
2.   `i`に`right`を代入する．
3.   `i-1`番目と`i`番目の要素を比較し，`array[i-1] > array[i]`ならば要素を交換し，`final`に`i`を代入する．
4.   `i != left + 1`のときには`i`を1減らし，3．へ戻る．`i = left + 1`のときには5.に進む．
5.   `left`に`final`を代入する．
6.   `i`に`left`を代入する．
7.   `i`番目と`i+1`番目の要素を比較し，`array[i] > array[i+1]`ならば要素を交換し，`final`に`i`を代入する．
8.   `i != right - 1`のときには`i`を1増やし，7．へ戻る．`i = right - 1`のときには9.に進む．
9.   `right`に`final`を代入する．
10.  `left < right`ならば2.に戻る．そうでなければ終了．

コード作成は発展課題として出題した．
"""

def shaker_sort(array):
  left, right = 0, len(array) - 1
  while left < right:
    for i in range(right, left, -1):
      if array[i - 1] > array[i]:
        array[i - 1], array[i] = array[i], array[i - 1]
        final = i
      print("途中過程(for i（左へ）)",array)
    left = final
    print("==============")
    for j in range(left, right):
      if array[j] > array[j + 1]:
        array[j], array[j + 1] = array[j + 1], array[j]
        final = j
      print("途中過程(for j（右へ）)",array)
    right = final
    print("==============")
  return array

random.shuffle(test1_list) #上記でtest1_listがソートされてしまったのでリスト要素をシャッフルする．randomのメソッドshuffleである．モジュールrandomに関する公式ドキュメント https://docs.python.org/ja/3/library/random.html　に掲載されている．（第03回にも出てきた）
print("original list=",test1_list)

sorted_test1_list = shaker_sort(test1_list)
print("shaker_sort(test1_list)=",sorted_test1_list)

"""## 単純挿入ソート(straight insertion sort)

### **解法4：単純挿入ソート(insertion sort)（シャトルソート：shuttle sort)**

1.   `i`に1を代入する．
2.   `j`に`i`を代入し，変数`tmp`に`array[i]`の値を代入（記憶用の変数）
3.   `j > 0`でありかつ`array[j - 1] > tmp`であるならば，`array[j]`に`array[j-1]`の値を代入する．そうでないときには，5.に移る．
4.   `j`を1減らし，3.に戻る．
5.   `array[j]`に`tmp`の値を代入する（2.で記憶していた値をここで代入する）
6.   `i < len(array) - 1`であれば`i`を1増やし，2.に戻る．そうでないときには終了．

以下を実現するコードは下記のようになる．

"""

def insert_sort(array):
  for i in range(1, len(array)):
    j = i
    tmp = array[i]

    while j > 0 and array[j-1] > tmp:
      array[j] = array[j-1]
      j -= 1
    
    array[j] = tmp
    #print("途中過程 for i",array)
  return array

random.shuffle(test1_list) #上記でtest1_listがソートされてしまったのでリスト要素をシャッフルする．randomのメソッドshuffleである．モジュールrandomに関する公式ドキュメント https://docs.python.org/ja/3/library/random.html　に掲載されている．（第03回にも出てきた）
print("original list=",test1_list)

sorted_test1_list = insert_sort(test1_list)
print("insert_sort(test1_list)=",sorted_test1_list)

"""**より進んだ話題**：二分探索（binary search)を用いた工夫もあるが，それは今後の講義（第07回または第08回）で取り扱う．

## シェルソート

### **解法5：シェルソート(Shell sort)（シャトルソート：shuttle sort)**

D. L. Shellによって考案された方法．

1.   `dis`に`len(array)//2`を代入する．
2.   `dis > 0`のとき，3.に進む．そうでないときは，5.に進む．
3.   `dis`飛ばしの小配列を単純挿入ソートする．
4.   `dis`を2で割り整数部分のみ取り，2.に戻る．
5.   終了

以下を実現するコードは下記のようになる．
"""

def shell_sort(array):
  dis = len(array) // 2

  while dis > 0:
    for i in range(dis, len(array)):
      j = i-dis
      tmp = array[i]

      while j >= 0 and array[j] > tmp:
        array[j+dis] = array[j]
        j -= dis

      array[j+dis] = tmp
      #print("途中過程 for i",array)
    dis //= 2
  
  return array

random.shuffle(test1_list) #上記でtest1_listがソートされてしまったのでリスト要素をシャッフルする．randomのメソッドshuffleである．モジュールrandomに関する公式ドキュメント https://docs.python.org/ja/3/library/random.html　に掲載されている．（第03回にも出てきた）
print("original list=",test1_list)

sorted_test1_list = shell_sort(test1_list)
print("shell_sort(test1_list)=",sorted_test1_list)

"""**シェルソートの工夫**

かき混ぜを十分に行うため，・・・→40個飛ばし→13個飛ばし→4個飛ばし→1個飛ばし(3×k+1)とすることを以下では考える．
"""

def shell_sort_modified(array):
  dis = 1

  while (dis < len(array) // 9):
    dis = 3*dis + 1
  
  while dis > 0:
    print("dis=",dis)
    for i in range(dis, len(array)):
      j = i - dis
      tmp = array[i]

      while j >= 0 and array[j] > tmp:
        array[j + dis] = array[j]
        j -= dis

      array[j + dis] = tmp
    dis //= 3
  
  return array

test2_list = [random.randint(0, 10000) for _ in range(100)] # 先ほども出てきたが，random.randint(a, b)はa<=N<=bであるようなランダムな整数Nを返す．for _ in range(100)で100回繰り返す（結果として，test1_listに要素数100のリストができる）．
print(test2_list)

print("original list=",test2_list)

sorted_test2_list = shell_sort_modified(test2_list)
print("shell_sort_modified(test2_list)=",sorted_test2_list)

"""## ソート済み配列のマージ

**要求：ソートされた2つの配列が用意されている．この2つの配列を併合（マージ）することを考える．その際，マージされた配列もソートされているものを作成せよ．**

"""

def merge_sorted_list(sorted_array_a, sorted_array_b=[]): #sorted_array_a, sorted_array_b は何らかの方法でソートされた配列.
  output_array = [None] * (len(sorted_array_a)+len(sorted_array_b)) # output_arrayは（将来）マージされた配列が入る．
  idx_a, idx_b, idx_o = 0, 0, 0 # idx_a, idx_b, idx_o はsorted_array_a, sorted_array_b, output_arrayの何番目の要素かを表す変数
  
  while idx_a < len(sorted_array_a) and idx_b < len(sorted_array_b): # idx_aがlen(sorted_array_a)を超えない，かつ，idx_bがlen(sorted_array_b)を超えないあいだじゅう以下を繰り返す．
    if sorted_array_a[idx_a] <= sorted_array_b[idx_b]:
      output_array[idx_o] = sorted_array_a[idx_a]
      idx_a += 1
    else:
      output_array[idx_o] = sorted_array_b[idx_b]
      idx_b += 1
    idx_o += 1
    #print("output_array=",output_array)

  # この段階で，idx_aがlen(sorted_array_a)を超えている，または，idx_bがlen(sorted_array_b)を超えている．
  while idx_a < len(sorted_array_a):
    output_array[idx_o] = sorted_array_a[idx_a]
    idx_a += 1
    idx_o += 1
    #print("output_array=",output_array)
  
  while idx_b < len(sorted_array_b):
    output_array[idx_o] = sorted_array_b[idx_b]
    idx_b += 1
    idx_o += 1
    #print("output_array=",output_array)

  return output_array

test3_list = list(range(0,16,2))
test4_list = list(range(1,45,4))

print("An original list (sorted)=",test3_list)
print("Another original list (sorted)=",test4_list)

merged_list = merge_sorted_list(test3_list, test4_list)
print("Merged list=",merged_list)

"""ソート済み配列のマージは以下のような書き方もできる．"""

def merge_sorted_list2(sorted_array_a, sorted_array_b=[]): #sorted_array_a, sorted_array_b は何らかの方法でソートされた配列．後々のため，sorted_array_bの初期値として，空のリストとしておく．
  buff = [] # 作業用配列．初期値として空のリストにしておく．
  i, j = 0, 0
  while i < len(sorted_array_a) and j < len(sorted_array_b):
    if sorted_array_a[i] < sorted_array_b[j]:
      buff.append(sorted_array_a[i]) # .appendはリストのメソッドである．第02回で学んだので，忘れた人は復習してみてください．buffというリスト末尾にsorted_array_a[i]の値を追加する．
      i += 1
      #print("buff=",buff)
    else:
      buff.append(sorted_array_b[j])
      j += 1
      #print("buff=",buff)
  return buff + sorted_array_a[i:] + sorted_array_b[j:] # リストにリストを結合する方法として，+が用いられることもある．第02回で学んだので，忘れた人は復習してみてください．

test3_list = list(range(0,16,2))
test4_list = list(range(1,45,4))

print("An original list (sorted)=",test3_list)
print("Another original list (sorted)=",test4_list)

merged_list = merge_sorted_list2(test3_list, test4_list)
print("Merged list=",merged_list)

"""## マージソート

**解法6：マージソート(merge sort)**

ソート済み配列のマージを用い，再帰的な呼び出しをすることでマージソートは実現できる．
"""

def merge_sort_recursion(array):
  if len(array) <= 1:
    return array
  mid_idx = len(array) // 2 #arrayの中心の引数を計算している．
  left = array[:mid_idx] # arrayのはじめから中心まで
  right = array[mid_idx:] # arrayの中心からおわりまで
  return merge_sorted_list2(merge_sort_recursion(left), merge_sort_recursion(right)) # 再帰を用いて定義（再帰については第04回で学んだので，わからない人は復習してください）

random.shuffle(test1_list) #上の方でtest1_listがソートされてしまったのでリスト要素をシャッフルする．randomのメソッドshuffleである．モジュールrandomに関する公式ドキュメント https://docs.python.org/ja/3/library/random.html　に掲載されている．（第03回にも出てきた）
print("original list=",test1_list)

sorted_test1_list = merge_sort_recursion(test1_list)
print("merge_sort_recursion(test1_list)=",sorted_test1_list)