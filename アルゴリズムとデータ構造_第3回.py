# -*- coding: utf-8 -*-
"""アルゴリズムとデータ構造_第3回.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1la9z-Bzhxn4eS0KYejOKqikBBNHkoZPT

# その1 : アルゴリズム設計とフローチャート
"""



"""次のフローチャートをPythonで書き下す．


"""

x, y = 2, 3
s = x * y
print(s)

"""次のフローチャートをPythonで書き下す．


"""

x, y = 5, 2
if x >= y:
  print(x)
else:
  print(y)

"""次のフローチャートをPythonで書き下す．

"""

sum = 0
for i in range(1, 11): # 1 <= i < 11 でループを回す．
  sum = sum + 1
print(sum)

"""# その2 : 計算量

## 時間計測手法

ALGORITHMの計算時間を測定するためには，
```
import time
time_start = time.time()
ALGORITHM
time_end = time.time()
time_elapsed = time_end - time_start
```
のようにすればよい．ここでimportしたtimeモジュールについては公式ドキュメント　https://docs.python.org/ja/3/library/time.html　を参照のこと．time.time()についてもこのウェブサイトに記載されている．
"""

import time
print(time.gmtime(0)) #time.gmtime()は，https://docs.python.org/ja/3/library/time.html#time.gmtimeに記載あり．
print(time.time())

"""## 繰り返し文

単一の繰り返し文の場合
"""

icount = 0
n = 100
time_start = time.time()
for i in range(n):
  icount += 1
time_end = time.time()
time_elapsed = time_end - time_start
print(icount)
print(time_elapsed)

"""二重の繰り返し文の場合"""

icount = 0
n = 100
time_start = time.time()
for i in range(n):
  for j in range(n):
    icount += 1
time_end = time.time()
time_elapsed = time_end - time_start
print(icount)
print(time_elapsed)

"""単一の繰り返し文，二重の繰り返し文の計算時間の`n`依存性


"""

import matplotlib.pyplot as plt
n_list = [100,200,500,1000,2000,5000,10000]
time_singleloop = []
time_doubleloop = []
for n in n_list:
  time_start = time.time()
  for i in range(n):
    icount += 1
  time_end = time.time()
  time_elapsed = time_end - time_start
  time_singleloop.append(time_elapsed)

  time_start = time.time()
  for i in range(n):
    for j in range(n):
      icount += 1
  time_end = time.time()
  time_elapsed = time_end - time_start
  time_doubleloop.append(time_elapsed)

"""単一の繰り返し文，二重の繰り返し文の計算時間の`n`依存性の可視化"""

plt.plot(n_list, time_singleloop, marker=".")
plt.plot(n_list, time_doubleloop, marker="x")
plt.xlim(0.,10000)
plt.ylim(0.,12)
plt.xlabel("n")
plt.ylabel("Computation time")
plt.minorticks_on()
plt.show()

"""単一の繰り返し文の計算時間の`n`依存性の可視化"""

plt.plot(n_list, time_singleloop, marker=".")
plt.xlim(0.,10000)
plt.ylim(0.,0.0015)
plt.xlabel("n")
plt.ylabel("Computation time")
plt.minorticks_on()
plt.show()

"""## 最大公約数

**問 : 2つの自然数a, bの最大公約数を求めよ．**

### 解法１ :
1.   変数xにbを代入
2.   aとbをxで割り，両方割り切れたらxを出力
3.   変数xの値を一つ減らす．2. に戻る．
"""

def gcd_sol1(a, b):
  x = b
  while True: # while Trueは無限ループ
    if a % x == 0 and b % x == 0: # a % x は a を x で割ったときの余り
      return x
    x -= 1

gcd_sol1(3, 12)

def gcd_sol1_mod(a, b):
  if a < b:
    a, b = b, a # a < b のときには a, bを交換（bが小さい方が効率的であるため）
  x = b
  while True:
    if a % x == 0 and b % x == 0:
      return x
    x -= 1

gcd_sol1_mod(3,12)

import random, time
# 「（共有用）第02回アルゴリズムとデータ構造.ipynb」にも出てきたが，randomについては， https://docs.python.org/ja/3/library/random.html を参照のこと．
# timeについては，https://docs.python.org/ja/3/library/time.html　を参照のこと．
random.seed(4)
a, b = random.randint(1e+6, 2e+6), random.randint(5e+6, 8e+6) # 「（共有用）第02回アルゴリズムとデータ構造.ipynb」にも出てきたが，random.randint(a, b)はa<=N<=bであるようなランダムな整数Nを返す．
print("a,b=",a, b)

time_start = time.time()
print("gcd of a and b=",gcd_sol1(a, b))
time_end = time.time()
time_elapsed = time_end - time_start
print("time of gcd_sol1()=",time_elapsed)

print("a,b=",a, b)
time_start = time.time()
print("gcd of a and b=",gcd_sol1_mod(a, b)) # a < b のときに a, bを交換した場合（これのほうが効率が良い）
time_end = time.time()
time_elapsed = time_end - time_start
print("time of gcd_sol1_mod()=",time_elapsed)

"""### 解法２ : ユークリッドの互除法(Euclidean algorithm)
1.   aをbで割った余りをrとする．
2.   rが0ならば，bを出力して終了する．
3.   aにbを，bにrを代入して1．へ戻る．


"""

def gcd_euclidean_algorithm(a, b):
  while True: # 無限ループ
    r = a % b
    if r == 0:
      return b # r=0のときにbを出力して終了する．
    a, b = b, r

print("a,b=",a, b)
time_start = time.time()
print("gcd of a and b=",gcd_euclidean_algorithm(a, b))
time_end = time.time()
time_elapsed = time_end - time_start
print("time of gcd_euclidean_algorithm()=",time_elapsed)

"""mathライブラリ https://docs.python.org/ja/3.6/library/math.html を用いた実装"""

import math
print("a,b=",a, b)
time_start = time.time()
print("gcd of a and b=",math.gcd(a, b)) # math.gcd(a, b)は整数 a と b の最大公約数を返す．https://docs.python.org/ja/3/library/math.html#math.gcd に記載されている．
time_end = time.time()
time_elapsed = time_end - time_start
print("time of math.gcd()=",time_elapsed)

a, b, c = 48957353977, 28974760517, 38966057247
gcd_of_a_and_b = math.gcd(a, b)
print(gcd_of_a_and_b)

gcd_of_a_and_b_and_c = math.gcd(gcd_of_a_and_b, c)
print(gcd_of_a_and_b_and_c)

print(math.gcd(a, c))

print(math.gcd(b, c))

"""## ソート

まずはじめに乱数を用いて配列を用意する．
"""

import random
test1_list = [random.randint(0, 10000) for _ in range(10)] # 先ほども出てきたが，random.randint(a, b)はa<=N<=bであるようなランダムな整数Nを返す．for _ in range(10)で10回繰り返す．
print(test1_list)

"""**要求 : 各要素に数値が入っている長さｎの配列について，各要素の数値が小さい順に並べ替えた配列を作成せよ．**

### 解法1 : 選択ソート

1.   iに0を代入する．
2.   iが配列の最後の添字なら終了する．
3.   i番目以降の要素の中からi番目よりも小さい最小の値を見つけ，その添字をjとする．
4.   3.で値が見つかったらi番目とj番目の要素を交換する．
5.   iを1増やし2.へ戻る．
"""

def selection_sort(array):
  x = array.copy() # リストのcopyメソッド．https://docs.python.org/ja/3/tutorial/datastructures.html のlist.copy()の項目を参照．リストのコピー．
  n = len(x) # 「（共有用）第02回アルゴリズムとデータ構造.ipynb」にも出てきたが，len(x)でリストのサイズを取得できる．
  for i in range(n):
    min_idx = i
    for j in range(i, n):
      if x[j] < x[min_idx]:
        min_idx = j
    if min_idx != i:
      x[i], x[min_idx] = x[min_idx], x[i]
  return x

print(test1_list)

time_start = time.time()
print(selection_sort(test1_list))
time_end = time.time()
time_elapsed = time_end - time_start
print("time of selection_sort()=",time_elapsed)

"""### 解法2 : 組み込み関数`sorted`を用いたソート"""

random.shuffle(test1_list) #上記でtest1_listがソートされてしまったのでリスト要素をシャッフルする．randomのメソッドshuffleである．モジュールrandomに関する公式ドキュメント https://docs.python.org/ja/3/library/random.html　に掲載されている．
print(test1_list)

time_start = time.time()
print(sorted(test1_list))
time_end = time.time()
time_elapsed = time_end - time_start
print("time of sorted()=",time_elapsed)

"""### 解法3 : リストの`sort`メソッドを用いたソート"""

random.shuffle(test1_list)
print(test1_list)

time_start = time.time()
test1_list.sort() # リストのsortメソッド．https://docs.python.org/ja/3/tutorial/datastructures.html　のlist.sort() を参照．sorted()と異なり，test1_list自体を書き換える．
print(test1_list)
time_end = time.time()
time_elapsed = time_end - time_start
print("time of sort method=",time_elapsed)

"""**練習 : より多くの要素を持つリストのソートを行う．**"""

test2_list = [random.randint(0, 512) for _ in range(1000)]
print(test2_list)

"""解法1の計算時間"""

print(test2_list)
time_start = time.time()
print(selection_sort(test2_list))
time_end = time.time()
time_elapsed = time_end - time_start
print("time of selection_sort()=",time_elapsed)

"""解法2の計算時間"""

random.shuffle(test2_list)
print(test2_list)
time_start = time.time()
print(sorted(test2_list))
time_end = time.time()
time_elapsed = time_end - time_start
print("time of sorted()=",time_elapsed)

"""解法3の計算時間"""

random.shuffle(test2_list)
print(test2_list)
time_start = time.time()
test2_list.sort()
print(test2_list)
time_end = time.time()
time_elapsed = time_end - time_start
print("time of sort method=",time_elapsed)