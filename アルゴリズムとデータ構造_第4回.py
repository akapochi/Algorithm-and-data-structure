# -*- coding: utf-8 -*-
"""アルゴリズムとデータ構造_第4回.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yDB2gKxaHi8MvpxmzMlRqRTUyqoH7mnO

# 再帰

今回は再帰について学ぶ．必要に応じて，プログラミング基礎同演習のテキスト（渡辺先生）の再帰の部分を参照するとよい．

https://kaityo256.github.io/python_zero/recursion/index.html

上記テキストによれば，「**再帰三カ条**」は

*   再帰とは，自分自身を呼び出す関数である
*   関数の最初に「終端条件」を記述する
*   「解きたい問題より小さな問題」に分解して自分自身を呼び出す

である（例外もありますが，それは出てきたときに上記「三カ条」を改めて考え直しましょう）．

## 階乗の計算

自然数の階乗$n!$を計算するための関数を定義し，実行してみる．
"""

def factorial(n): # factorial() という関数を定義．
  if n <= 0:
    return 1 # n <= 0 なら値1を返す（三カ条の「終端条件」の記述）
  return n * factorial(n - 1) # n * factorial(n-1)を返す．（三カ条の「自分自身を呼び出す関数」「解きたい問題より小さな問題」に分解して自分を呼び出す，の記述）

factorial(3)

"""何が起こっているかをもう少しわかりやすくするために，`n`の変化について見てみる．"""

def factorial_detail(n): # factorial_detail() という関数を定義．
  print("n=", n)
  if n <= 0:
    return 1 # n <= 0 なら値1を返す（三カ条の「終端条件」の記述）
  return n * factorial_detail(n - 1) # n * factorial_detail(n-1)を返す．（三カ条の「自分自身を呼び出す関数」「解きたい問題より小さな問題」に分解して自分を呼び出す，の記述）

factorial_detail(3)

"""## ユークリッドの互除法

問：2つの自然数a, bの最大公約数を求めよ．

1.   aをbで割った余りをrとする．
2.   rが0ならば，bを出力して終了する．
3.   aにbを，bにrを代入して1．へ戻る．

まずは前回（第03回）の復習
"""

def gcd_euclidean_algorithm(a, b):
  while True: # 無限ループ
    r = a % b
    if r == 0:
      return b # r=0のときにbを出力して終了する．
    a, b = b, r

gcd_euclidean_algorithm(15, 18)

"""何が起こっているかをもう少しわかりやすくするために，`a`, `b`の変化について見てみる．"""

def gcd_euclidean_algorithm_detail(a, b):
  while True: # 無限ループ
    print("a,b=", a, b)
    r = a % b
    if r == 0:
      return b # r=0のときにbを出力して終了する．
    a, b = b, r

gcd_euclidean_algorithm_detail(15, 18)

"""上記のユークリッドの互除法のプログラムを再帰を使って書き直してみる．"""

def gcd_euclidean_algorithm_recursion(a, b):
  r = a % b
  if r == 0:
    return b # r== 0 なら値1を返す（三カ条の「終端条件」の記述）
  return gcd_euclidean_algorithm_recursion(b, r) # gcd_euclidean_algorithm_recursion(b, r)を返す．（三カ条の「自分自身を呼び出す関数」「解きたい問題より小さな問題」に分解して自分を呼び出す，の記述）

gcd_euclidean_algorithm_recursion(15, 18)

"""何が起こっているかをもう少しわかりやすくするために，`a`, `b`の変化について見てみる．"""

def gcd_euclidean_algorithm_recursion_detail(a, b):
  print("a,b=", a, b)
  r = a % b
  if r == 0:
    return b # r== 0 なら値1を返す（三カ条の「終端条件」の記述）
  return gcd_euclidean_algorithm_recursion_detail(b, r) # gcd_euclidean_algorithm_recursion(b, r)を返す．（三カ条の「自分自身を呼び出す関数」「解きたい問題より小さな問題」に分解して自分を呼び出す，の記述）

gcd_euclidean_algorithm_recursion_detail(15, 18)

"""**練習：二重階乗の計算を再帰を使って実行してみる．**

自然数$n$に対し，$n!!$は二重階乗(double factorial)あるいは半階乗(semifactorial)と呼ばれ，階乗の「1つ飛ばし」である．

*   偶数$n$に対する二重階乗は，$n!! = \prod_{k=1}^{n/2} (2k)$
*   奇数$n$に対する二重階乗は，$n!! = \prod_{k=1}^{(n+1)/2} (2k-1)$

例）

*   $3!! = 3 \times 1 = 3$
*   $4!! = 4 \times 2 = 8$
*   $5!! = 5 \times 3 \times 1 = 15$
*   $6!! = 6 \times 4 \times 2 = 48$

"""

def double_factorial_recursion(n):
  if n == 0:
    return 1 # （三カ条の「終端条件」の記述）
  elif n == 1: # n=0でないかつn=1のとき(elif)
    return 1 # （三カ条の「終端条件」の記述）
  return n * double_factorial_recursion(n-2)

double_factorial_recursion(4)

"""**練習：組合せの計算を再帰を使って実行してみる．**

${}_nC_k = \left( \begin{array}{1} n \\ k \end{array} \right)$の計算を行う($n \ge k > 0$)．

$\left( \begin{array}{1} n \\ k \end{array} \right) = \left( \begin{array}{1} n-1 \\ k-1 \end{array} \right) + \left( \begin{array}{1} n-1 \\ k \end{array} \right)$ を利用する．
"""

def combination_recursion(n, k):
  if (k == 0 or n == k): 
    return 1 # （三カ条の「終端条件」の記述）
  else:
    return combination_recursion(n - 1, k - 1) + combination_recursion(n - 1, k)

combination_recursion(5, 3)

"""基礎問題3"""

def question3(n):
  if n == 1:
    return 1
  else:
    return 3 * n + question3(n - 1)

question3(6)

"""基礎問題4"""

def question4_f(n):
  if n <= 1:
    return 1
  else:
    return 2 * n * question4_g(n-1)
  
def question4_g(n):
  if n <= 0:
    return 0
  else:
    return n + question4_f(n-1)

question4_f(4)

"""\begin{align}
f(4) &= 2 \times 4 \times g(3) \\
&= 8 \times (3 + f(2)) \\
&= 24 + 8 \times (2 \times 2 \times g(1)) \\
&= 24 + 32 \times (1 + f(0)) \\
&= 24 + 32 \times 2 \\
&= 88
\end{align}
"""

question4_g(4)

"""\begin{align}
g(4) &= 4 + f(3) \\
&= 4 + (2 \times 3 \times g(2)) \\
&= 4 + 6 \times (2 + f(1)) \\
&= 4 + 6 \times (2 + 1) \\
&= 22 
\end{align}

## ハノイの塔

小さいものが上に，大きいものが下になるように重ねられた円盤を3本のタワーの中で移動する問題を考えよう．ただしここで全ての円盤の大きさは異なっているものとし，一つのタワーに全ての円盤が重ねられているとしよう．

このとき全ての円盤を別のタワーに最小の回数で移動することを考えよう．移動は1枚ずつであり，かつ，より大きい円盤を（一時的にでも）上に重ねることはできないものとする．
"""

def count_hanoi(num, tower_x, tower_y):
  count = 1;
  def hanoi(num, tower_x, tower_y): # num個の円盤をtower_xからtower_yに動かす．
    nonlocal count
    if num <= 0: # 例外処理
      print('num should be positive integer.')
      return

    if tower_x < 1 or tower_x > 3: # 例外処理
      print('tower_x should be 1<=tower_x<=3')
      return

    if tower_y < 1 or tower_y > 3: # 例外処理
      print('tower_y should be 1<=tower_y<=3')
      return

    if tower_x == tower_y: # 例外処理
      print('no move.')
      return

    if num > 1:
      hanoi(num - 1, tower_x, 6 - tower_x - tower_y)
      """
      一番底の円盤を除いたグループを「初期タワー」から「目的タワー」へ移動する．
      tower_x, tower_y = 1, 2, 3であることから，6 - tower_x - tower_y で「中間タワー」を表現できる．
      例) tower_x = 1, tower_y = 2 であれば， 中間タワーは 3
      """

    print(f'{count}手目:円盤[{num}]をタワー{tower_x}からタワー{tower_y}へ移動') # 「初期タワー」から「目的タワー」へ移動したことを表示
    count += 1;

    if num > 1:
      hanoi(num - 1, 6 - tower_x - tower_y, tower_y) #先程のグループを「中間タワー」から「目的タワー」へ移動する．
  hanoi(num, tower_x, tower_y)

count_hanoi(3, 1, 3) # 3個の円盤がタワー1に積まれており，これをタワー3に移動する．

count_hanoi(3, 3, 1) # 3個の円盤がタワー3に積まれており，これをタワー1に移動する．

count_hanoi(3, 1, 2) # 3個の円盤がタワー1に積まれており，これをタワー2に移動する．

count_hanoi(4, 1, 3)  # 4個の円盤がタワー1に積まれており，これをタワー3に移動する．

"""## （補足）Pythonでの再帰呼び出し数の上限の調べ方"""

import sys # sys については https://docs.python.org/ja/3/library/sys.html を参照のこと（第02回でも sys については紹介）．
sys.getrecursionlimit() # 上記URLに説明が載っている．

sys.setrecursionlimit(2500)

"""## フィボナッチ数列

フィボナッチ数列(Fibonacci sequence)$\{F_n\}$は以下の漸化式で定義される．

*   $F_0=0$
*   $F_1=1$
*   $F_{n+2} = F_{n} + F_{n+1}$ ($n \ge 0$)

以下，フィボナッチ数列を計算するコードを作成してみる．
"""

def fibonacci_recursion(n):
  if n == 0:
    return 0
  if n == 1:
    return 1
  return fibonacci_recursion(n - 1) + fibonacci_recursion(n - 2)

fibonacci_recursion(2)

fibonacci_recursion(12)

for n in range(0,16):
  fibo_n = fibonacci_recursion(n)
  print(n, fibo_n)

"""上記計算の可視化をしてみる．この可視化については，プログラミング基礎同演習の渡辺先生のテキスト

https://github.com/kaityo256/python_zero/blob/master/recursion/README.md

を参照．あるいは `graphviz` のドキュメント

https://graphviz.readthedocs.io/en/stable/manual.html

を参照．
"""

from graphviz import Digraph
def fibonacci_recursion_g(n, g, nodes, parent=None):
    index = str(len(nodes))
    nodes.append(index)
    g.node(index, str(n))

    if parent is not None:
        g.edge(index, parent)

    if n in (1, 2):
        return
    fibonacci_recursion_g(n-1, g, nodes, index)
    fibonacci_recursion_g(n-2, g, nodes, index)

n = 5
graph = Digraph()
graph.attr(size="10,10")
fibonacci_recursion_g(n, graph, [])
graph

"""## （発展）メモ化

上記のフィボナッチ数列の計算には無駄がある．

`fibonacci_recursion(4)`を求めるのに`fibonacci_recursion(3)`と`fibonacci_recursion(2)`を求める必要があり，`fibonacci_recursion(5)`を求めるのに`fibonacci_recursion(4)`と`fibonacci_recursion(3)`を求める必要がある．つまり重複した計算を実行してしまう．

重複した計算を実行しないようにするためにメモ化（計算した項の情報を保存する）を行う．

### メモ化の有無と計算時間，再帰関数の実行回数の比較

先程作った関数を少し変更．
"""

count_fibonacci_recursion = 0

def fibonacci_recursion(n):
  global count_fibonacci_recursion
  count_fibonacci_recursion += 1
  if n == 0:
    return 0
  if n == 1:
    return 1
  return fibonacci_recursion(n - 1) + fibonacci_recursion(n - 2)

"""メモ化用辞書を作成．"""

memo = {0:0, 1:1} # メモ用辞書を作成．F_0 = 0, F_1 = 1 に対応．
count_fibonacci_recursion_w_memo = 0

def fibonacci_recursion_w_memo(n):
    global count_fibonacci_recursion_w_memo
    count_fibonacci_recursion_w_memo += 1
    if n not in memo:
      memo[n] = fibonacci_recursion_w_memo(n - 1) + fibonacci_recursion_w_memo(n - 2) # メモに記録されていないときのみ計算
    return memo[n]

"""計算が正しく動いていることをチェック．"""

print(fibonacci_recursion(5))
print(fibonacci_recursion_w_memo(5))

import time # timeモジュールについては公式ドキュメント　https://docs.python.org/ja/3/library/time.html　を，time.time()についてもこのウェブサイトに記載されている．（第03回でも紹介）
time_start = time.time()
print(fibonacci_recursion(36))
time_end = time.time()
time_elapsed = time_end - time_start
print("time of fibonacci_recursion()=",time_elapsed,"count_fibonacci_recursion=",count_fibonacci_recursion)

time_start = time.time()
print(fibonacci_recursion_w_memo(36))
time_end = time.time()
time_elapsed = time_end - time_start
print("time of fibonacci_recursion_w_memo()=",time_elapsed,"count_fibonacci_recursion_w_memo=",count_fibonacci_recursion_w_memo)

"""更に興味のある人は`lru_cache()`について調べてみるとよい．"""

from functools import lru_cache # 公式ドキュメント：https://docs.python.org/ja/3/library/functools.html　を参照．

count_fibonacci_recursion_lrucache = 0
@lru_cache(maxsize=None)
def fibonacci_recursion_lrucache(n):
    global count_fibonacci_recursion_lrucache
    count_fibonacci_recursion_lrucache += 1
    if n < 2:
        return n
    return fibonacci_recursion_lrucache(n - 1) + fibonacci_recursion_lrucache(n - 2)

time_start = time.time()
print(fibonacci_recursion_lrucache(36))
time_end = time.time()
time_elapsed = time_end - time_start
print("time of fibonacci_recursion_lrucache()=",time_elapsed,"count_fibonacci_recursion_lrucache=",count_fibonacci_recursion_lrucache)

"""トリボナッチ数列"""

from functools import lru_cache
@lru_cache(maxsize=None)

def tribonacci_recursion(n):
  if n == 0:
    return 0
  if n == 1:
    return 0
  if n == 2:
    return 1
  return tribonacci_recursion(n - 1) + tribonacci_recursion(n - 2) + tribonacci_recursion(n - 3)

for n in range(0,41):
  tri_n = tribonacci_recursion(n)
  print(n, tri_n)

