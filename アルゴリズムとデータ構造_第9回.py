# -*- coding: utf-8 -*-
"""アルゴリズムとデータ構造_第9回.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ivh9vgQaqawKs9b1TrCW7iYokhGYc0TO

# NetworkXの利用

公式ドキュメント https://networkx.org/documentation/stable/index.html を見てみると様々な機能があることがわかる．

## グラフを描画する
"""

import networkx as nx
graph = nx.Graph()
graph.add_edge(1, 2) # ノード1とノード2の間にエッジを追加．
graph.add_edge(2, 3) # ノード2とノード3の間にエッジを追加．

nx.draw_networkx(graph)

"""ノードの色を変える．"""

nx.draw_networkx(graph, edge_color = "black", node_color = "cyan")

"""ノードを追加．"""

graph.add_edge(2, 4) # ノード2とノード4の間にエッジを追加．
graph.add_edge(3, 4) # ノード3とノード4の間にエッジを追加．
nx.draw_networkx(graph, edge_color = "black", node_color = "cyan")

"""## グラフ作成"""

import random
def generate_graph(num_vertices, num_edges):

  graph_data = [[0] * num_vertices for _ in range(num_vertices)]
  # print(graph_data)

  edge_set = set() # set型は集合を扱う型 https://docs.python.org/ja/3/tutorial/datastructures.html の5.4や，https://docs.python.org/ja/3/library/stdtypes.html のset(集合)型を参照

  while len(edge_set) < num_edges:
    i, j = random.sample(range(num_vertices), 2) # https://docs.python.org/ja/3/library/random.html#random.sample を参照
    if i > j:
      i, j = j, i
    edge_set.add((i, j)) # set型のedge_setに(i,j)を追加するメソッド，add
    graph_data[i][j] = graph_data[j][i] = 1

  return graph_data, edge_set

"""グラフ作成例1"""

random.seed(5)
test_graph1, test_edge_set1 = generate_graph(8,24)

print(test_edge_set1)

test_graph1

graph1 = nx.Graph()
for u, v in test_edge_set1:
    graph1.add_edge(u, v)
nx.draw_networkx(graph1, edge_color = "black", node_color = "cyan")

"""グラフ作成例2"""

random.seed(3)
test_graph2, test_edge_set2 = generate_graph(16, 16)

test_graph2

graph2 = nx.Graph()
for u, v in test_edge_set2:
    graph2.add_edge(u, v)
nx.draw_networkx(graph2, edge_color = "black", node_color = "cyan")

"""# グラフ探索のアルゴリズム

## グラフの幅優先探索

グラフの幅優先探索を行う前に，「キュー」について見ていく．
モジュール`collection`については　https://docs.python.org/ja/3/library/collections.html を，`deque`クラスについては，上記ページの deque の説明を参照
"""

from collections import deque

queue = deque([]) # dequeは両端における append や pop を高速に行えるリスト風のコンテナである．
print(queue)

"""末尾に一つずつデータを追加するためには，`append`メソッドを用いる．第02回でみてみたリストの`append`メソッドと（振る舞いとしては）類似．"""

queue.append(12)
queue.append(32)
queue.append(18)
print(queue)

"""先頭の要素を取り出すためには，`popleft`メソッドを用いる．"""

print(queue.popleft())
print(queue)

"""`deque`の他のメソッドについては，https://docs.python.org/ja/3/library/collections.html#collections.deque　をみて試してみると良い．

先程導入したキューを用いて，グラフの幅優先探索を行う．
"""

def breadth_first_search(start_vertex, adj_matrix):

  work_queue = deque([]) # dequeは直上で学んだもの
  visited = set() # set型は集合を扱う型 https://docs.python.org/ja/3/tutorial/datastructures.html の5.4や，https://docs.python.org/ja/3/library/stdtypes.html　のset(集合)型を参照

  work_queue.append(start_vertex)
  visited.add(start_vertex) # set型のvisitedにstart_vertexの値を追加するメソッド，add

  while work_queue: #work_queueが空になるまで繰り返す
    print("work_queue=",work_queue)
    print("visited=",visited)
    print("------")

    here = work_queue.popleft()

    for i, node in enumerate(adj_matrix[here]): # enumerate()については，https://docs.python.org/ja/3/library/functions.html#enumerate　を参照．
      print("here, i, node, adj_matrix[here]:" ,here, i, node, adj_matrix[here])

      if node == 0:
        continue

      if i not in visited: # i が リストvisitedに入っていなければ下記を実行
        print("i=",i)
        work_queue.append(i)
        visited.add(i)

  return visited

"""さきほどつくった test_graph2, graph2 について見ていこう．"""

breadth_first_search(11, test_graph2)

breadth_first_search(12, test_graph2)

breadth_first_search(14, test_graph2)

breadth_first_search(8, test_graph2)

breadth_first_search(15, test_graph2)

"""## 深さ優先探索

スタックを用いて深さ優先探索を実行．
"""

def depth_first_search(start_vertex, adj_matrix):

  # リストをスタックとして利用．
  work_stack = [] #初期値として，空のリスト
  visited = set()

  work_stack.append(start_vertex)
  visited.add(start_vertex)

  while work_stack:
    print("work_stack=",work_stack)
    print("visited=",visited)

    here = work_stack.pop()
    for i, node in enumerate(adj_matrix[here]):
      print("here, i, node, adj_matrix[here]:" ,here, i, node, adj_matrix[here])

      if node == 0:
        continue

      if i not in visited:
        print("i=",i)
        work_stack.append(i)
        visited.add(i)

  return visited

"""さきほどつくった test_graph2, graph2 について見ていこう．"""

depth_first_search(11, test_graph2)

depth_first_search(12, test_graph2)

depth_first_search(14, test_graph2)

depth_first_search(8, test_graph2)

depth_first_search(15, test_graph2)