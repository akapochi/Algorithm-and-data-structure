# -*- coding: utf-8 -*-
"""アルゴリズムとデータ構造_第7回.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oYoaKNc2AAzjzXd8Mmb8wNImwIRtAmzf

# データの探索

データ探索対象となる配列を用意する．
"""

import random
test_list1 = list(range(0,30,2)) # [0, 2, 4, ..., 28]なるリストを返す．
print("test_list1:", test_list1)

random.shuffle(test_list1) # randomのメソッドshuffleである．モジュールrandomに関する公式ドキュメント https://docs.python.org/ja/3/library/random.html　に掲載されている．（第03回でも用いた）
print("test_list1:", test_list1)

"""## Pythonで簡単にデータ探索を行う方法

Python公式ドキュメントの「6.10.2. 所属検査演算」を見ていこう．
https://docs.python.org/ja/3/reference/expressions.html#membership-test-operations

`x in s`は，`x`が`s`の要素であれば`True`
"""

14 in test_list1

51 in test_list1

"""`x not in s`は`x in s`の否定"""

51 not in test_list1

14 not in test_list1

"""リストのindexメソッドを使ってデータ探索を行う．
https://docs.python.org/ja/3/tutorial/datastructures.html
を参照のこと．
"""

print("test_list1:", test_list1)
test_list1.index(0)

test_list1.index(51) # test_list1に入っていないとエラーが出る．

"""## 線形探索"""

def linear_search1(array, target):
  i = 0
  while True: # 終端条件になるまで繰り返す．
    if i == len(array): # 終端を通り越していないかチェック
      return False
    if array[i] == target: # 探索すべき値(target)と等しい要素を見つけているかいないかチェック
      return str(target) + "は" + str(i) + "番目にあります"
    i += 1 # 次の要素に着目するためインクリメント

print(test_list1)
print(linear_search1(test_list1, 28))
print(linear_search1(test_list1, 13))

"""### 番兵法"""

def linear_search2(array, target):
  array.append(target) # リスト末尾にtargetの値を追加．appendはリストのメソッド．第02回で出てきた．

  i = 0
  while True:
    if array[i] == target:
      break
    i += 1

  del array[-1] # array[-1]でarrayの最終要素（今回の場合はarray.append(target)で追加したtarget）を削除．
  if i == len(array):
    return False
  else:
    return i

"""番兵を消したことを確認．"""

print(test_list1)

print(linear_search2(test_list1, 28))
print(test_list1)

print(linear_search2(test_list1, 13))
print(test_list1)

"""他の書き方"""

def linear_search3(array, target):
  for i in range(len(array)):
    if array[i] == target:
      return i
  return False

print(test_list1)

print(linear_search3(test_list1, 28))
print(linear_search3(test_list1, 13))

"""時間計測"""

import time

test_list2 = list(range(0,20000,2)) # [0, 2, 4, ..., 19998]なるリストを返す．
print("test_list2:", test_list2)

random.shuffle(test_list2) # randomのメソッドshuffleである．モジュールrandomに関する公式ドキュメント https://docs.python.org/ja/3/library/random.html　に掲載されている．（第03回でも用いた）
print("test_list2(random):", test_list2)
print("--------")

iterations = 5000
search_target = 13

time_start = time.time()
for _ in range(iterations):
  linear_search1(test_list2, search_target)
print("time of linear_search1=",time.time()-time_start)

time_start = time.time()
for _ in range(iterations):
  linear_search2(test_list2, search_target)
print("time of linear_search2=",time.time()-time_start)

time_start = time.time()
for _ in range(iterations):
  linear_search3(test_list2, search_target)
print("time of linear_search3=",time.time()-time_start)

"""## 二分探索

二分探索を行うために，ソートされた配列を用意する．
"""

test_sorted_list1 = sorted(test_list1)
print(test_sorted_list1)

def binary_search(sorted_array, target):
  idx_l = 0 #左端を表すインデックス
  idx_r = len(sorted_array) - 1 #右端を表すインデックス

  while True:
    idx_c = (idx_l + idx_r) // 2 #中央を表すインデックス
    if sorted_array[idx_c] == target:
      return idx_c
    elif sorted_array[idx_c] < target:
      idx_l = idx_c + 1
    else:
      idx_r = idx_c - 1
    
    if idx_l > idx_r:
      break
  
  return False

print(test_sorted_list1)
print(binary_search(test_sorted_list1, 20))
print(binary_search(test_sorted_list1, 23))

"""### 標準モジュール`bisect`を用いた二分探索について見ていく．

https://github.com/python/cpython/blob/master/Lib/bisect.py

`bisect.bisect`は，挿入箇所を探索する関数

ソート済みリストの中に，挿入しようとするものと同じ値がもともと入っていない場合．
"""

import bisect


print(test_sorted_list1)
print(bisect.bisect(test_sorted_list1, 5))

"""ソート済みリストの中に，挿入しようとするものと同じ値がもともと入っている場合．"""

print(test_sorted_list1)
print(bisect.bisect(test_sorted_list1, 6))

"""`.bisect_right`と`.bisect_left`の振る舞いの違いに注目．"""

print(test_sorted_list1)
print(bisect.bisect_right(test_sorted_list1, 6))
print(bisect.bisect_left(test_sorted_list1, 6))

"""`.bisect_right`と`.bisect_left`の振る舞いの違いがよりわかりやすい例"""

test_sorted_list2 = [1, 2, 3, 3, 3, 3, 4, 4, 5]
print(test_sorted_list2)
print(bisect.bisect_right(test_sorted_list2, 3))
print(bisect.bisect_left(test_sorted_list2, 3))

test_list3 = [1, 2, 2, 2, 2, 3, 4]
bisect.bisect_left(test_list3, 2)

bisect.bisect_right(test_list3, 2)

"""# 二分探索木

以下のコードは次回（第08回）で使います．`class`を用いたコーディングについて不安がある人は，渡辺先生の「プログラミング基礎同演習」のテキスト　https://kaityo256.github.io/python_zero/class/index.html　を参考に勉強しておいてください．
"""

class Node: #Nodeのクラスを用意．

  def __init__(self, value): # クラスの初期化のためのメソッド __init__
    self.value = value
    self.left = None
    self.right = None

  def __str__(self): # オブジェクトを文字列にして返すメソッド __str__
    left = f'[{self.left.value}]' if self.left else '[]'
    right = f'[{self.right.value}]' if self.right else '[]'
    return f'{left} <- {self.value} -> {right}'


class BinarySearchTree: #BinarySearchTreeのクラスを用意．
  def __init__(self): # クラスの初期化のためのメソッド __init__
    self.nodes = [] # 最初は空

  def add_node(self, value): # ノードを追加．
    node = Node(value)
    if self.nodes: # self.nodesがNoneでなければif文通過

      parent, direction = self.find_parent(value)
      #print("value:", value)
      #print("parent:", parent)
      #print("direction:", direction)
      #print("-----")
      
      if direction == 'left':
        parent.left = node
      else:
        parent.right = node
      
    self.nodes.append(node)

  def find_parent(self, value): # 親を見つける．
    node = self.nodes[0]

    while node: # nodeがNoneでないあいだじゅうずっと以下が実行される
      p = node  # 戻り値の候補（親かもしれない）としてとっておく．
      if p.value == value:
        raise ValueError('Cannot add the value that is the same as the values already added.')
      if p.value > value:
        direction = 'left'
        node = p.left
      else:
        direction = 'right'
        node = p.right
    return p, direction

"""[10,20,49,4,3,9,30]について，二分探索木をつくる．"""

btree = BinarySearchTree()
for v in [10, 20, 49, 4, 3, 9, 30]:
  btree.add_node(v)

for node in btree.nodes:
  print(node)

btree = BinarySearchTree()
for v in [39, 99, 34, 10, 20, 98, 75, 89]:
  btree.add_node(v)

for node in btree.nodes:
  print(node)

btree = BinarySearchTree()
for v in [10, 20, 34, 39, 75, 89, 98, 99]:
  btree.add_node(v)

for node in btree.nodes:
  print(node)

"""同じ値がある場合，エラーになる．"""

btree2 = BinarySearchTree()
for v in [1, 2, 2, 3, 4, 5, 6, 7]:
  btree2.add_node(v)

for node in btree2.nodes:
  print(node)

"""基礎問題1"""

random.shuffle(test_list1)
print("test_list1:", test_list1)
min, max = test_list1[0], test_list1[0]
print("min: " + str(min))
print("max: " + str(max))
print("=========")
for index in range(1, len(test_list1)):
  if test_list1[index] < min:
    min = test_list1[index]
  if test_list1[index] > max:
    max = test_list1[index]
  print("min: " + str(min))
  print("max: " + str(max))
  print("=========")
  
max - min

